
# 면접복기 2 - 코드 품질 관리 & CI/CD & 협업 플로우

## ✅ 코드 품질 관리를 위한 도구 및 흐름

### 1. 유닛 테스트
- **도구**: Jest
- **설명**: 컴포넌트 단위의 로직 검증을 위한 테스트 코드 작성
- **활용 시점**: 개발 중 및 CI 파이프라인에서 자동 실행

### 2. E2E 테스트
- **도구**: Playwright
- **설명**: 사용자 시나리오 기반 전체 흐름 테스트
- **활용 시점**: Staging 환경에 배포된 후, QA 전 수동 실행
- **CI 파이프라인에는 포함하지 않음**
  - 이유: 시간 소요가 크고, 실행 환경이 복잡할 수 있음

### 3. Prettier & ESLint
- **활용 시점**: Git commit 시점 (lint-staged + husky 사용)
- **역할**:
  - Prettier: 코드 스타일 자동 정리 (format on save)
  - ESLint: 문법 오류 및 코드 품질 검토

### 4. GitLab MR & Jenkins 기반 CI 파이프라인
- **트리거 방식**: GitLab Webhook → Jenkins 파이프라인 자동 실행
- **수행 단계**:
  1. Jest 기반 유닛 테스트
  2. ESLint 검사
  3. Build 오류 검사
- **조건부 머지**:
  - 테스트 커버리지 부족, 빌드 실패 시 머지 불가
  - 결과는 Slack 알림으로 연동하여 공유

---

## 🚫 CD는 자동화하지 않음 (Staging & 운영 서버 모두)

### 1️⃣ 운영 서버 CD 미적용 이유
- 운영 배포는 사용자에게 직접 영향
- QA 검토 후 수동 배포 방식 유지
- Slack 알림을 통해 QA 및 서버 개발자와 배포 타이밍 공유

### 2️⃣ Staging 환경 CD 미적용 이유
- 프론트와 백엔드 기능이 항상 동시에 준비되지 않음
  - 프론트는 기능 UI 먼저 개발
  - 백엔드는 API를 개인 서버에 먼저 구축
- Staging에 프론트만 자동 배포되면 API 미반영 상태로 기능 깨짐
- 기능 동기화된 시점에 수동 배포하는 방식이 더 실용적

---

## 🤝 프론트 & 백엔드 협업 플로우 요약

### 1. 기능 기획 & 역할 분담
- 프론트: UI/UX 및 컴포넌트 개발
- 백엔드: API 설계 및 구현

### 2. 개발 초기 대응
- API 미완성 시: 목 서버를 활용한 컴포넌트 개발
- API 완성 시: 백엔드 개발자의 개인 서버와 연동하여 실제 API 테스트

### 3. 기능 완료 후 MR 생성
- MR 생성 → CI 파이프라인 통해 유닛 테스트, Lint, Build 확인
- 리뷰어 피드백 반영 → 머지 가능한 상태 유지

### 4. 코드 머지 및 버전 통합
- 기능 또는 버전 타이밍에 맞춰 병합
- 프론트/백 동시에 병합하여 새 버전 준비

### 5. Staging 환경 배포
- Docker 이미지 생성
- 서버팀에 전달하여 Staging 서버에 프론트/백엔드 함께 배포

### 6. QA 전 E2E 테스트
- 프론트팀 내부에서 playwright로 기본 동작 점검

### 7. QA 진행 및 수정
- QA 테스트 → 피드백 반영

### 8. 운영 배포
- QA 완료 후 운영 환경에 수동 배포
